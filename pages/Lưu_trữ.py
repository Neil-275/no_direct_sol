import streamlit as st
from openai import OpenAI
from prompts.prompts import Tutor_prompt
import os
import dotenv
import json
import uuid
from serpapi import GoogleSearch
import PyPDF2
from datetime import datetime
import time

SESSION_FILE = "chat_sessions.json"

def load_sessions():
    if os.path.exists(SESSION_FILE):
        with open(SESSION_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    return []

def save_sessions(sessions):
    with open(SESSION_FILE, "w", encoding="utf-8") as f:
        json.dump(sessions, f, ensure_ascii=False, indent=2)

def serpapi_search(query, api_key):
    """Enhanced web search with better error handling and formatting"""
    try:
        params = {
            "engine": "google",
            "q": query,
            "api_key": api_key,
            "num": 5,
            "hl": "vi"
        }
        search = GoogleSearch(params)
        results = search.get_dict()
        organic = results.get("organic_results", [])
        
        if not organic:
            return "Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£ web search."
        
        output = []
        for i, item in enumerate(organic, 1):
            title = item.get("title", "")
            link = item.get("link", "")
            snippet = item.get("snippet", "")
            output.append(f"**{i}. {title}**\n{snippet}\nüîó {link}")
        
        return "\n\n".join(output)
    except Exception as e:
        return f"‚ö†Ô∏è Kh√¥ng th·ªÉ l·∫•y k·∫øt qu·∫£ web search: {str(e)}"

def extract_pdf_content(uploaded_files):
    """Extract text content from uploaded PDF files"""
    content = ""
    file_info = []
    
    for uploaded_file in uploaded_files:
        try:
            reader = PyPDF2.PdfReader(uploaded_file)
            file_content = ""
            for page_num, page in enumerate(reader.pages, 1):
                page_text = page.extract_text() or ""
                file_content += page_text
            
            content += f"\n\n=== {uploaded_file.name} ===\n{file_content}"
            file_info.append({
                "name": uploaded_file.name,
                "pages": len(reader.pages),
                "size": len(file_content)
            })
        except Exception as e:
            st.error(f"‚ùå L·ªói ƒë·ªçc file {uploaded_file.name}: {str(e)}")
    
    return content, file_info

def get_session_preview(messages, max_length=50):
    """Get a preview of the session from the first user message"""
    if not messages:
        return "Phi√™n tr·ªëng"
    
    first_user_msg = next((msg for msg in messages if msg["role"] == "user"), None)
    if not first_user_msg:
        return "Phi√™n tr·ªëng"
    
    preview = first_user_msg["content"].strip()
    return preview[:max_length] + "..." if len(preview) > max_length else preview

def format_timestamp(timestamp=None):
    """Format timestamp for display"""
    if timestamp is None:
        timestamp = datetime.now().isoformat()
    try:
        dt = datetime.fromisoformat(timestamp)
        return dt.strftime("%d/%m %H:%M")
    except:
        return datetime.now().strftime("%d/%m %H:%M")

def format_timestamp(timestamp=None):
    """Format timestamp for display"""
    if timestamp is None:
        timestamp = datetime.now().isoformat()
    try:
        dt = datetime.fromisoformat(timestamp)
        return dt.strftime("%d/%m %H:%M")
    except:
        return datetime.now().strftime("%d/%m %H:%M")

# Configure page
st.set_page_config(
    page_title="TutorBot - Web Enhanced AI Tutor",
    page_icon="üåê",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for modern UI
st.markdown("""
<style>
    /* Hide default Streamlit elements */
    #MainMenu {visibility: hidden;}
    .stDeployButton {visibility: hidden;}
    header {visibility: hidden;}
    
    /* Custom styling */
    .main-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 1.5rem;
        border-radius: 12px;
        margin-bottom: 2rem;
        text-align: center;
        color: white;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }
    
    .feature-badge {
        background: rgba(255, 255, 255, 0.2);
        padding: 4px 12px;
        border-radius: 20px;
        font-size: 0.9em;
        margin: 0 4px;
        display: inline-block;
        backdrop-filter: blur(10px);
    }
    
    .session-item {
        background: white;
        padding: 12px;
        border-radius: 8px;
        margin: 8px 0;
        border-left: 4px solid #667eea;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
    }
    
    .session-item:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
    }
    
    .pdf-upload-area {
        background: #f8f9fa;
        border: 2px dashed #667eea;
        border-radius: 10px;
        padding: 20px;
        text-align: center;
        margin: 10px 0;
    }
    
    .pdf-info {
        background: #e8f4f8;
        border: 1px solid #bee5eb;
        border-radius: 8px;
        padding: 12px;
        margin: 8px 0;
    }
    
    .search-result {
        background: #fff3cd;
        border: 1px solid #ffeaa7;
        border-radius: 8px;
        padding: 15px;
        margin: 10px 0;
    }
    
    .search-result h4 {
        color: #856404;
        margin: 0 0 8px 0;
    }
    
    .typing-indicator {
        display: flex;
        align-items: center;
        margin: 10px 0;
        color: #666;
    }
    
    .typing-dots {
        display: flex;
        margin-left: 10px;
    }
    
    .typing-dots span {
        height: 8px;
        width: 8px;
        background-color: #667eea;
        border-radius: 50%;
        display: inline-block;
        margin: 0 2px;
        animation: typing 1.4s infinite ease-in-out;
    }
    
    .typing-dots span:nth-child(1) { animation-delay: 0s; }
    .typing-dots span:nth-child(2) { animation-delay: 0.2s; }
    .typing-dots span:nth-child(3) { animation-delay: 0.4s; }
    
    @keyframes typing {
        0%, 60%, 100% { transform: translateY(0); }
        30% { transform: translateY(-15px); }
    }
    
    .status-card {
        background: white;
        padding: 16px;
        border-radius: 10px;
        border: 1px solid #e9ecef;
        margin: 8px 0;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }
    
    .status-online {
        border-left: 4px solid #28a745;
    }
    
    .status-offline {
        border-left: 4px solid #dc3545;
    }
    
    .feature-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
        margin: 20px 0;
    }
    
    .feature-card {
        background: white;
        padding: 20px;
        border-radius: 10px;
        border: 1px solid #e9ecef;
        text-align: center;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        transition: transform 0.2s ease;
    }
    
    .feature-card:hover {
        transform: translateY(-4px);
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
    }
    
    .feature-icon {
        font-size: 2em;
        margin-bottom: 10px;
    }
    
    .web-search-spinner {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
        background: #f8f9fa;
        border-radius: 8px;
        margin: 10px 0;
    }
    
    .search-indicator {
        display: flex;
        align-items: center;
        background: #e3f2fd;
        border: 1px solid #bbdefb;
        border-radius: 20px;
        padding: 8px 16px;
        margin: 8px 0;
        font-size: 0.9em;
    }
    
    .search-indicator .spinner {
        width: 16px;
        height: 16px;
        border: 2px solid #2196f3;
        border-top: 2px solid transparent;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-right: 8px;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .api-status {
        font-size: 0.9em;
        padding: 8px 12px;
        border-radius: 20px;
        margin: 4px 0;
        display: inline-block;
    }
    
    .api-status.connected {
        background: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
    }
    
    .api-status.disconnected {
        background: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
    }
</style>
""", unsafe_allow_html=True)

# Load environment variables
dotenv.load_dotenv()

# Initialize session state
if "current_session_id" not in st.session_state:
    st.session_state["current_session_id"] = None
if "messages" not in st.session_state:
    st.session_state["messages"] = []
if "show_menu" not in st.session_state:
    st.session_state["show_menu"] = None
if "confirm_new" not in st.session_state:
    st.session_state["confirm_new"] = False
if "confirm_delete" not in st.session_state:
    st.session_state["confirm_delete"] = None
if "typing" not in st.session_state:
    st.session_state["typing"] = False
if "searching" not in st.session_state:
    st.session_state["searching"] = False

# Main header
st.markdown("""
<div class="main-header">
    <h1>üåê TutorBot Web Enhanced</h1>
    <p>Tr·ª£ l√Ω AI th√¥ng minh v·ªõi t√≠ch h·ª£p Web Search & PDF</p>
    <div>
        <span class="feature-badge">üìÑ PDF Upload</span>
        <span class="feature-badge">üîç Web Search</span>
        <span class="feature-badge">ü§ñ AI Chat</span>
        <span class="feature-badge">üíæ Session Save</span>
    </div>
</div>
""", unsafe_allow_html=True)

# Load sessions
sessions = load_sessions()

# API Keys status
monica_api_key = os.getenv('MONICA_API_KEY', '')
serpapi_key = os.getenv('SERPAPI_KEY', '')

# Sidebar
with st.sidebar:
    st.markdown("### üîß C·∫•u h√¨nh & T√†i li·ªáu")
    
    # API Status
    st.markdown("#### üîë Tr·∫°ng th√°i API")
    if monica_api_key:
        st.markdown('<div class="api-status connected">‚úÖ Monica API: ƒê√£ k·∫øt n·ªëi</div>', unsafe_allow_html=True)
    else:
        st.markdown('<div class="api-status disconnected">‚ùå Monica API: Ch∆∞a k·∫øt n·ªëi</div>', unsafe_allow_html=True)
    
    if serpapi_key:
        st.markdown('<div class="api-status connected">‚úÖ SerpAPI: ƒê√£ k·∫øt n·ªëi</div>', unsafe_allow_html=True)
    else:
        st.markdown('<div class="api-status disconnected">‚ùå SerpAPI: Ch∆∞a k·∫øt n·ªëi</div>', unsafe_allow_html=True)
    
    st.markdown("---")
    
    # PDF Upload Section
    st.markdown("#### üìÑ T·∫£i l√™n t√†i li·ªáu PDF")
    uploaded_pdfs = st.file_uploader(
        "Ch·ªçn file PDF ƒë·ªÉ tham kh·∫£o", 
        type=["pdf"], 
        accept_multiple_files=True,
        help="T·∫£i l√™n c√°c file PDF ƒë·ªÉ TutorBot c√≥ th·ªÉ tham kh·∫£o th√¥ng tin t·ª´ t√†i li·ªáu c·ªßa b·∫°n"
    )
    
    pdf_content = ""
    pdf_info = []
    
    if uploaded_pdfs:
        with st.spinner("üîÑ ƒêang x·ª≠ l√Ω file PDF..."):
            pdf_content, pdf_info = extract_pdf_content(uploaded_pdfs)
        
        if pdf_info:
            st.success(f"‚úÖ ƒê√£ t·∫£i th√†nh c√¥ng {len(uploaded_pdfs)} file PDF")
            
            # Display PDF info
            for info in pdf_info:
                st.markdown(f"""
                <div class="pdf-info">
                    <strong>üìÑ {info['name']}</strong><br>
                    üìë {info['pages']} trang<br>
                    üìä {info['size']} k√Ω t·ª±
                </div>
                """, unsafe_allow_html=True)
    
    st.markdown("---")
    
    # Session Management
    st.markdown("### üí¨ Qu·∫£n l√Ω phi√™n chat")
    
    # Statistics
    total_sessions = len(sessions)
    total_messages = sum(len(s.get("messages", [])) for s in sessions)
    
    col1, col2 = st.columns(2)
    with col1:
        st.metric("Phi√™n chat", total_sessions)
    with col2:
        st.metric("Tin nh·∫Øn", total_messages)
    
    # New chat button
    if st.button("üÜï Phi√™n chat m·ªõi", type="primary", use_container_width=True):
        st.session_state["confirm_new"] = True
        st.rerun()
    
    # Confirm new chat
    if st.session_state.get("confirm_new"):
        st.warning("‚ö†Ô∏è B·∫°n c√≥ ch·∫Øc mu·ªën t·∫°o phi√™n chat m·ªõi?")
        col1, col2 = st.columns(2)
        with col1:
            if st.button("‚úÖ X√°c nh·∫≠n", type="primary"):
                new_id = str(uuid.uuid4())
                new_session = {
                    "id": new_id,
                    "name": "",
                    "messages": [],
                    "created_at": datetime.now().isoformat(),
                    "updated_at": datetime.now().isoformat()
                }
                sessions.append(new_session)
                save_sessions(sessions)
                st.session_state["current_session_id"] = new_id
                st.session_state["messages"] = []
                st.session_state["confirm_new"] = False
                st.success("‚úÖ ƒê√£ t·∫°o phi√™n chat m·ªõi!")
                time.sleep(1)
                st.rerun()
        with col2:
            if st.button("‚ùå H·ªßy"):
                st.session_state["confirm_new"] = False
                st.rerun()
    
    st.markdown("---")
    st.markdown("### üìã Danh s√°ch phi√™n chat")
    
    if not sessions:
        st.markdown("""
        <div style="text-align: center; padding: 2rem; color: #666;">
            <p>üîç Ch∆∞a c√≥ phi√™n chat n√†o</p>
            <p>H√£y t·∫°o phi√™n chat m·ªõi ƒë·ªÉ b·∫Øt ƒë·∫ßu!</p>
        </div>
        """, unsafe_allow_html=True)
    else:
        # Sort sessions by updated_at (most recent first)
        sessions.sort(key=lambda x: x.get("updated_at", ""), reverse=True)
        
        for session in sessions:
            is_current = session["id"] == st.session_state["current_session_id"]
            
            # Session container
            container = st.container()
            with container:
                col1, col2 = st.columns([4, 1])
                
                with col1:
                    session_name = session.get("name", "") or get_session_preview(session.get("messages", []))
                    button_type = "primary" if is_current else "secondary"
                    
                    if st.button(
                        f"{'üîµ' if is_current else '‚ö™'} {session_name}",
                        key=f"session_{session['id']}",
                        type=button_type,
                        use_container_width=True
                    ):
                        st.session_state["current_session_id"] = session["id"]
                        st.session_state["messages"] = session.get("messages", [])
                        st.session_state["show_menu"] = None
                        st.rerun()
                
                with col2:
                    if st.button("‚ãÆ", key=f"menu_{session['id']}"):
                        st.session_state["show_menu"] = session["id"] if st.session_state.get("show_menu") != session["id"] else None
                        st.rerun()
                
                # Show menu if selected
                if st.session_state.get("show_menu") == session["id"]:
                    if st.button("üóëÔ∏è X√≥a", key=f"delete_{session['id']}", type="secondary", use_container_width=True):
                        st.session_state["confirm_delete"] = session["id"]
                        st.rerun()
                    
                    # Show session info
                    st.caption(f"üìÖ {format_timestamp(session.get('created_at'))}")
                    st.caption(f"üí¨ {len(session.get('messages', []))} tin nh·∫Øn")
                
                # Confirm delete
                if st.session_state.get("confirm_delete") == session["id"]:
                    st.error("‚ö†Ô∏è B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a phi√™n n√†y?")
                    col1, col2 = st.columns(2)
                    with col1:
                        if st.button("‚úÖ X√°c nh·∫≠n", key=f"confirm_delete_{session['id']}", type="primary"):
                            sessions = [s for s in sessions if s["id"] != session["id"]]
                            save_sessions(sessions)
                            st.session_state["show_menu"] = None
                            st.session_state["confirm_delete"] = None
                            
                            if st.session_state["current_session_id"] == session["id"]:
                                if sessions:
                                    st.session_state["current_session_id"] = sessions[0]["id"]
                                    st.session_state["messages"] = sessions[0].get("messages", [])
                                else:
                                    st.session_state["current_session_id"] = None
                                    st.session_state["messages"] = []
                            
                            st.success("‚úÖ ƒê√£ x√≥a phi√™n chat!")
                            time.sleep(1)
                            st.rerun()
                    with col2:
                        if st.button("‚ùå H·ªßy", key=f"cancel_delete_{session['id']}"):
                            st.session_state["confirm_delete"] = None
                            st.rerun()
                
                st.markdown("---")

# Main chat area
col1, col2 = st.columns([3, 1])

with col1:
    # Current session info
    if st.session_state["current_session_id"]:
        current_session = next((s for s in sessions if s["id"] == st.session_state["current_session_id"]), None)
        if current_session:
            session_name = current_session.get("name", "") or get_session_preview(current_session.get("messages", []))
            st.markdown(f"### üí¨ {session_name}")
            
            # Session metadata
            col_a, col_b, col_c = st.columns(3)
            with col_a:
                st.caption(f"üìÖ {format_timestamp(current_session.get('created_at'))}")
            with col_b:
                st.caption(f"üí¨ {len(current_session.get('messages', []))} tin nh·∫Øn")
            with col_c:
                st.caption(f"üîÑ {format_timestamp(current_session.get('updated_at'))}")
            
            st.session_state["messages"] = current_session.get("messages", [])
    else:
        st.markdown("### üí¨ Ch·ªçn phi√™n chat ho·∫∑c t·∫°o m·ªõi")
        
        # Feature showcase
        st.markdown("""
        <div class="feature-grid">
            <div class="feature-card">
                <div class="feature-icon">üîç</div>
                <h4>Web Search</h4>
                <p>T√¨m ki·∫øm th√¥ng tin m·ªõi nh·∫•t t·ª´ internet</p>
            </div>
            <div class="feature-card">
                <div class="feature-icon">üìÑ</div>
                <h4>PDF Upload</h4>
                <p>T·∫£i l√™n v√† ph√¢n t√≠ch t√†i li·ªáu PDF</p>
            </div>
            <div class="feature-card">
                <div class="feature-icon">ü§ñ</div>
                <h4>AI Chat</h4>
                <p>Tr√≤ chuy·ªán th√¥ng minh v·ªõi AI</p>
            </div>
        </div>
        """, unsafe_allow_html=True)
        
        st.info("üëà H√£y ch·ªçn m·ªôt phi√™n chat t·ª´ sidebar ho·∫∑c t·∫°o phi√™n m·ªõi ƒë·ªÉ b·∫Øt ƒë·∫ßu!")

with col2:
    # Quick actions and status
    st.markdown("### ‚ö° Thao t√°c nhanh")
    
    if st.button("üîÑ L√†m m·ªõi", use_container_width=True):
        st.rerun()
    
    if st.button("üì§ Xu·∫•t chat", use_container_width=True):
        if st.session_state["messages"]:
            chat_export = {
                "session_id": st.session_state["current_session_id"],
                "messages": st.session_state["messages"],
                "pdf_files": [info["name"] for info in pdf_info] if pdf_info else [],
                "exported_at": datetime.now().isoformat()
            }
            st.download_button(
                "üíæ T·∫£i xu·ªëng",
                data=json.dumps(chat_export, ensure_ascii=False, indent=2),
                file_name=f"chat_export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json",
                mime="application/json"
            )
        else:
            st.warning("Kh√¥ng c√≥ tin nh·∫Øn ƒë·ªÉ xu·∫•t!")
    
    # Status indicators
    st.markdown("---")
    st.markdown("### üìä Tr·∫°ng th√°i")
    
    if pdf_info:
        st.markdown(f"üìÑ **PDF:** {len(pdf_info)} file ƒë√£ t·∫£i")
    else:
        st.markdown("üìÑ **PDF:** Ch∆∞a t·∫£i file n√†o")
    
    if st.session_state.get("searching"):
        st.markdown("üîç **Web Search:** ƒêang t√¨m ki·∫øm...")
    else:
        st.markdown("üîç **Web Search:** S·∫µn s√†ng")

# Chat interface
if st.session_state["current_session_id"]:
    # Messages container
    messages_container = st.container()
    
    with messages_container:
        # Display messages
        for message in st.session_state["messages"]:
            with st.chat_message(message["role"]):
                st.markdown(message["content"])
        
        # Typing indicator
        if st.session_state.get("typing"):
            with st.chat_message("assistant"):
                st.markdown("""
                <div class="typing-indicator">
                    <span>TutorBot ƒëang so·∫°n tin nh·∫Øn</span>
                    <div class="typing-dots">
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                </div>
                """, unsafe_allow_html=True)
    
    # Chat input
    if prompt := st.chat_input("üí≠ ƒê·∫∑t c√¢u h·ªèi, t√¨m ki·∫øm th√¥ng tin ho·∫∑c th·∫£o lu·∫≠n v·ªÅ t√†i li·ªáu..."):
        # Add user message
        st.session_state["messages"].append({"role": "user", "content": prompt})
        
        # Update session name if first message
        for s in sessions:
            if s["id"] == st.session_state["current_session_id"]:
                if len(st.session_state["messages"]) == 1:
                    s["name"] = prompt[:30] + "..." if len(prompt) > 30 else prompt
                s["messages"] = st.session_state["messages"]
                s["updated_at"] = datetime.now().isoformat()
        save_sessions(sessions)
        
        # Display user message
        with st.chat_message("user"):
            st.markdown(prompt)
        
        # Web search
        web_results = ""
        if serpapi_key:
            st.session_state["searching"] = True
            
            # Show search indicator
            search_placeholder = st.empty()
            with search_placeholder:
                st.markdown("""
                <div class="search-indicator">
                    <div class="spinner"></div>
                    üîç ƒêang t√¨m ki·∫øm th√¥ng tin tr√™n internet...
                </div>
                """, unsafe_allow_html=True)
            
            web_results = serpapi_search(prompt, serpapi_key)
            st.session_state["searching"] = False
            search_placeholder.empty()
            
            # Display web results
            if web_results and "Kh√¥ng t√¨m th·∫•y" not in web_results:
                with st.expander("üîç K·∫øt qu·∫£ Web Search", expanded=True):
                    st.markdown(f"""
                    <div class="search-result">
                        <h4>üåê Th√¥ng tin t·ª´ Internet</h4>
                        {web_results}
                    </div>
                    """, unsafe_allow_html=True)
        
        # Check API keys
        if not monica_api_key:
            st.error("‚ùå Kh√¥ng t√¨m th·∫•y Monica API key. Vui l√≤ng ki·ªÉm tra file .env")
        else:
            # Initialize Monica client
            client = OpenAI(
                base_url="https://openapi.monica.im/v1",
                api_key=monica_api_key,
            )
            
            # Prepare messages for API
            messages = [{"role": "system", "content": Tutor_prompt}]
            
            # Add PDF content if available
            if pdf_content:
                messages.append({
                    "role": "system",
                    "content": f"N·ªôi dung t√†i li·ªáu PDF ng∆∞·ªùi d√πng cung c·∫•p (∆∞u ti√™n s·ª≠ d·ª•ng th√¥ng tin n√†y n·∫øu li√™n quan):\n{pdf_content[:4000]}\n(H·∫øt tr√≠ch ƒëo·∫°n, ch·ªâ d√πng ƒë·ªÉ tham kh·∫£o tr·∫£ l·ªùi n·∫øu li√™n quan)"
                })
            
            # Add web search results if available
            if web_results and "Kh√¥ng t√¨m th·∫•y" not in web_results and "Kh√¥ng th·ªÉ l·∫•y" not in web_results:
                messages.append({
                    "role": "system",
                    "content": f"K·∫øt qu·∫£ web search li√™n quan (ch·ªâ d√πng n·∫øu t√†i li·ªáu PDF kh√¥ng ƒë·ªß th√¥ng tin):\n{web_results}"
                })
            
            # Add conversation history
            messages += [{"role": m["role"], "content": m["content"]} for m in st.session_state["messages"]]
            
            # Generate response
            with st.chat_message("assistant"):
                message_placeholder = st.empty()
                full_response = ""
                
                # Set typing indicator
                st.session_state["typing"] = True
                
                try:
                    # Stream response
                    for response in client.chat.completions.create(
                        model="gpt-4.1-mini",
                        messages=messages,
                        stream=True
                    ):
                        content = getattr(response.choices[0].delta, "content", "")
                        full_response += content if isinstance(content, str) else ""
                        message_placeholder.markdown(full_response + "‚ñå")
                    
                    # Final response
                    message_placeholder.markdown(full_response)
                    st.session_state["typing"] = False
                    
                    # Add assistant message
                    st.session_state["messages"].append({"role": "assistant", "content": full_response})
                    
                    # Save session
                    # Save session
                    for s in sessions:
                        if s["id"] == st.session_state["current_session_id"]:
                            s["messages"] = st.session_state["messages"]
                            s["updated_at"] = datetime.now().isoformat()
                            break
                    save_sessions(sessions)
                    
                except Exception as e:
                    st.session_state["typing"] = False
                    st.error(f"‚ùå L·ªói khi g·ªçi API: {str(e)}")
                    st.info("üí° H√£y ki·ªÉm tra API key v√† k·∫øt n·ªëi internet")

# Footer
st.markdown("---")
st.markdown("""
<div style="text-align: center; padding: 2rem; color: #666;">
    <p>üåê <strong>TutorBot Web Enhanced</strong> - Powered by Monica AI & SerpAPI</p>
    <p>üìö H·ªó tr·ª£ PDF Upload | üîç Web Search | üí¨ AI Chat | üíæ Session Management</p>
    <div style="margin-top: 1rem;">
        <span style="margin: 0 10px;">üìß Support: contact@tutorbot.com</span>
        <span style="margin: 0 10px;">üîó GitHub: github.com/tutorbot</span>
        <span style="margin: 0 10px;">üìñ Docs: docs.tutorbot.com</span>
    </div>
</div>
""", unsafe_allow_html=True)

# Auto-scroll to bottom (JavaScript)
st.markdown("""
<script>
    function scrollToBottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }
    
    // Auto-scroll when new messages arrive
    const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                setTimeout(scrollToBottom, 100);
            }
        });
    });
    
    observer.observe(document.body, { childList: true, subtree: true });
</script>
""", unsafe_allow_html=True)

# Cleanup and optimization
if st.session_state.get("typing") and not st.session_state.get("searching"):
    time.sleep(0.1)  # Small delay to prevent excessive rerunning

# Performance monitoring (optional)
if st.checkbox("üîß Debug Mode", value=False):
    st.markdown("### üîç Debug Information")
    
    col1, col2 = st.columns(2)
    with col1:
        st.json({
            "current_session_id": st.session_state.get("current_session_id"),
            "messages_count": len(st.session_state.get("messages", [])),
            "total_sessions": len(sessions),
            "typing": st.session_state.get("typing", False),
            "searching": st.session_state.get("searching", False)
        })
    
    with col2:
        st.json({
            "pdf_files_loaded": len(pdf_info) if pdf_info else 0,
            "pdf_content_length": len(pdf_content) if pdf_content else 0,
            "monica_api_configured": bool(monica_api_key),
            "serpapi_configured": bool(serpapi_key),
            "session_file_exists": os.path.exists(SESSION_FILE)
        })
    
    if st.button("üßπ Clear Session State"):
        for key in list(st.session_state.keys()):
            del st.session_state[key]
        st.success("‚úÖ Session state cleared!")
        st.rerun()

# Error handling wrapper
try:
    # Validate session integrity
    if st.session_state.get("current_session_id"):
        current_session = next((s for s in sessions if s["id"] == st.session_state["current_session_id"]), None)
        if not current_session:
            st.warning("‚ö†Ô∏è Phi√™n chat hi·ªán t·∫°i kh√¥ng t·ªìn t·∫°i. ƒêang t·∫°o phi√™n m·ªõi...")
            st.session_state["current_session_id"] = None
            st.session_state["messages"] = []
            st.rerun()
    
    # Auto-save sessions periodically
    if len(st.session_state.get("messages", [])) > 0:
        current_time = datetime.now()
        last_save = st.session_state.get("last_auto_save")
        
        if not last_save or (current_time - datetime.fromisoformat(last_save)).seconds > 30:
            # Auto-save every 30 seconds
            for s in sessions:
                if s["id"] == st.session_state["current_session_id"]:
                    s["messages"] = st.session_state["messages"]
                    s["updated_at"] = current_time.isoformat()
                    break
            save_sessions(sessions)
        except Exception as e:
            st.error(f"An error occurred: {e}")
